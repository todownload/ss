Learn Linux and Shell

Chapter 1
1.Linux four part
-->Linux内核
--->系统内存管理
--->软件程序管理
--->硬件设备管理
--->文件系统管理

-->GNU工具
--->用以处理文件的工具
--->用以操作文本的工具
--->用以管理进程的工具

-->图形化桌面环境
--->X Window系统
--->KDE桌面
--->GNOME桌面
--->Unity桌面 //in ubuntu
--->其他桌面

-->应用软件

2.Linux 发行版
-->核心 Linux 发行版
-->特定用途的 Linux 发行版
-->Linux LiveCD


Chapter 2
1.进入命令行
-->控制台终端
-->图形化终端

2.通过 Linux 控制台终端访问 CLI
-->Ctrl+Alt组合键,然后按功能键(F1~F7)进入要使用的虚拟控制台。
-->Linux发行版通常使用Ctrl+Alt组合键配合F1或F7来进入图形界面。Ubuntu使用F7,而
   RHEL则使用F1。

3.通过图形化终端仿真访问 CLI

4.使用 GNOME Terminal 仿真器
-->访问 GNOME Terminal  //Ctrl+Alt+T
-->菜单栏

5.使用 Konsole Terminal 仿真器
-->访问 Konsole Terminal
-->菜单栏

6.使用 xterm 终端仿真器
-->访问 xterm
-->命令行参数


Chapter 3
1.启动 shell
2.shell 提示符
3.bash 手册  // man -k terminal  e.g. man cp
4.浏览文件系统
-->Linux 文件系统  ---Linux虚拟目录中比较复杂的部分是它如何协调管理各个存储设  备。在Linux PC上安装的第一块硬盘称为根驱动器。根驱动器包含了虚拟目录的核心,其他目录都是从那里开始构建的。Linux会在根驱动器上创建一些特别的目录,我们称之为挂载点(mount point)。挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中,然而实际上它们却存储在另外一个驱动器中。

-->遍历目录
--->cd des -- cd 命令可接受单个参数 destination ,用以指定想切换到的目录名。
--->pwd -- return current index
---->绝对文件路径  绝对文件路径总是以正斜线(/)作为起始,指明虚拟文件系统的根目录。
---->相对文件路径  相对文件路径允许用户指定一个基于当前位置的目标文件路径。相对文件路径不以代表根目录的正斜线(/)开头,而是以目录名(如果用户准备切换到当前工作目录下的一个目录)或是一个特殊字符开始。 有两个特殊字符可用于相对文件路径中:单点符(.),表示当前目录;双点符(..),表示当前目录的父目录。

5.文件和目录列表
-->基本列表功能
--->ls -- 最基本的形式会显示当前目录下的文件和目录 输出的列表是按字母排序的(按列排序而不是按行排序) 
----> -F 参数在目录名后加了正斜线(/),以方便用户在输出中分辨它们。类似地,它会在可执行文件(比如上面的my_script文件)的后面加个星号,
----> -R 参数是 ls 命令可用的另一个参数,叫作递归选项。它列出了当前目录下包含的子目录中的文件。
---> -i 查看文件或目录的inode 编号 可以看出独立文件
-->显示长列表
---> ls -l -- 这种长列表格式的输出在每一行中列出了单个文件或目录。除了文件名,输出中还有其他有用信息。输出的第一行显示了在目录中包含的总块数。在此之后,每一行都包含了关于文件(或目录)的下述信息:文件类型,比如目录( d )、文件( - )、字符型文件( c )或块设备( b )
;文件的权限(参见第6章);文件的硬链接总数;文件属主的用户名;文件属组的组名;文件的大小(以字节为单位);文件的上次修改时间;文件名或目录名。
-->过滤输出列表
---> ls [option]regexp //指定特定文件的名称作为过滤器时 问号( ? )代表一个字符; 星号( * )代表零个或多个字符 ; 中括号 可能出现的字符 ; 使用感叹号(!)将不需要的内容排除在外。

6. 处理文件
-->创建文件
---> touch filename -- 创建了你指定的新文件,并将你的用户名作为文件的属主。
----> -a -- 只想改变访问时间
-->复制文件
--->cp source destination -- 当 source 和 destination 参数都是文件名时, cp 命令将源文件复制成一个新文件,并且以destination 命名。新文件就像全新的文件一样,有新的修改时间。
----> -i -- 强制shell询问是否需要覆盖已有文件
----> -R -- 可以用它在一条命令中递归地复制整个目录的内容
            e.g. cp -R Scripts/Mod_Scripts
---->des = directory/   //将文件复制到目录中
---->des = .   //将文件复制到当前工作目录
-->制表键自动补全
--->制表键自动补全允许你在输入文件名或目录名时按一下制表键,让shell帮忙将内容补充完整
-->链接文件
--->ln -s sou des //符号链接
--->ln sou des //硬链接
--->符号链接 -- 实实在在的文件 彼此的内容并不相同
--->硬链接 -- 建独立的虚拟文件,其中包含了原始文件的信息及位置 同一个文件
-->重命名文件
--->mv -- 可以将文件和目录移动到另一个位置或重新命名
--->mv file new_name -- 重新命名
--->mv file path --  移动
----> -i -- 在命令试图覆盖已有的文件时,你就会得到提示。
-->删除文件
--->rm [option] file 
----> -i -- 提示你是不是要真的删除该文件
----> -f -- 强制删除
----> -r -- 使得命令可以向下进入目录,删除其中的文件,然后再删除目录本身

7.处理目录
-->创建目录
--->mkdir new_dir  -- 创建目录
----> -p -- 可以根据需要创建缺失的父目录
-->删除目录
--->rmdir dir -- 默认情况下只删除空目录 要解决这一问题,得先把目录中的文件删掉

8.查看文件内容
-->查看文件类型
--->file -- 它能够探测文件的内部,并决定文件是什么类型的 can identify 目录
-->查看整个文件
--->cat file -- 显示文本文件中所有数据的得力工具
----> -n -- 会给所有的行加上行号
----> -b -- 只想给有文本的行加上行号
----> -T -- 不想让制表符出现 用 ^I 字符组合去替换文中的所有制表符
--->more file -- 会显示文本文件的内容,但会在显示每页数据之后停下来
--->less file -- 一次显示一屏的文件文本 包括更多的选项
-->查看部分文件
--->tail -- 默认情况下,它会显示文件的末尾10行
----> -n num -- 修改所显示的行数 只显示文件的最后num行
----> -f -- 允许你在其他进程使用该文件时查看文件的内容
--->head -- 默认情况下,它会显示文件前10行
----> -n num -- 修改所显示的行数 只显示文件的前num行
---->tail/head -num 修改所显示的行数


Chapter 4
1.监测程序
-->探查进程
--->ps -- 显示运行在当前控制台下的属于当前用户的进程
--->Unix风格的参数
----> -e -- 显示所有进程
----> -f -- 显示完整格式的输出
--->BSD风格的参数
--->GNU长参数
-->实时监测进程
--->top -- 实时显示进程信息
-->结束进程
--->kill pids -- 会向命令行中列出的全部PID发送一个 TERM 信号 必须是进程的属主或root用户
---->-s -- 支持指定其他信号 (用信号名或信号值)
--->killall -- 支持通过进程名而不是PID来结束进程 支持通配符

2.监测磁盘空间
-->挂载存储媒体
--->mount -- 输出当前系统上挂载的设备列表
--->umount -- 卸载设备 umount [directory | device ] 
-->使用 df 命令
--->df -- 查看所有已挂载磁盘的使用情况
----> -f -- 把输出中的磁盘空间按照用户易读的形式显示
-->使用 du 命令
--->du -- 可以显示某个特定目录(默认情况下是当前目录)的磁盘使用情况
----> -c -- 显示所有已列出文件总的大小
----> -h -- 按用户易读的格式输出大小
----> -s -- 显示每个输出参数的总计

3.处理数据文件
-->排序数据
--->sort file -- 按照会话指定的默认语言的排序规则对文本文件中的数据行排序
----> -n -- 把数字识别成数字而不是字符,并且按值排序
----> -M -- 按月排序 能识别三字符的月份名 //Jan ..
----> -i -- 在排序时忽略不可打印字符
----> -t -- 指定一个用来区分键位置的字符
----> -k pos1 ,[pos2] -- 排序从POS1位置开始;如果指定了POS2的话,到POS2位置结束
----> -r -- 反序排序(升序变成降序)
-->搜索数据
--->grep [opt] pattern [file] -- grep 命令会在输入或指定的文件中查找包含匹配指定模式的字符的行
----> -v -- 进行反向搜索(输出不匹配该模式的行)
----> -n -- 要显示匹配模式的行所在的行号
----> -c -- 只要知道有多少行含有匹配的模式
----> -e pat1 -e pat2 -- 要指定多个匹配模式
--->egrep -- 是 grep 的一个衍生,支持POSIX扩展正则表达式
-->压缩数据
--->zip(zip [opt] des sour) & unzip
--->gzip & gzcat(查看压缩过的文本文件的内容) & gunzip 
-->归档数据
---> tar function [opts] obj1 obj2  -- 用来归档数据
---->function 
----> -A --concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件
----> -c --create 创建一个新的tar归档文件
----> -d --diff 检查归档文件和文件系统的不同之处
---->    --delete 从已有tar归档文件中删除
----> -r --append 追加文件到已有tar归档文件末尾
----> -t --list 列出已有tar归档文件的内容
----> -u --update 将比tar归档文件中已有的同名文件新的文件追加到该tar归档文件中
----> -x --extract 从已有tar归档文件中提取文件
---->option
----> -C dir 切换到指定目录
----> -f file 输出结果到文件或设备 file
----> -j 将输出重定向给 bzip2 命令来压缩内容
----> -p保留所有文件权限
----> -v在处理文件时显示文件
----> -z将输出重定向给 gzip 命令来压缩内容


Chapter 5
1.shell 的类型
2.shell 的父子关系
--->输入命令 bash之后,一个子shell就出现了 只有部分父进程的环境被复制到子shell环境中
-->进程列表 
--->你可以在一行中指定要依次运行的一系列命令。这可以通过命令列表来实现,只需要在命令之间加入分号(;)即可。
--->命令列表要想成为进程列表,这些命令必须包含在括号里 括号的加入使命令列表变成了进程列表,生成了一个子shell来执行对应的命令。
-->别出心裁的子 shell 用法
--->探索后台模式 要想将命令置入后台模式,可以在命令末尾加上字符 &
--->jobs -- 显示出当前运行在后台模式中的所有用户的进程
----> -l -- 能够看到更多的相关信息
--->将进程列表置入后台 (process-list)&
--->协程  可以同时做两件事。它在后台生成一个子shell,并在这个子shell中执行命令。
--->coproc cmd

3.理解 shell 的内建命令
--->which cmd || type cmd  //know the info of cmd
-->外部命令 是存在于bash shell之外的程序 //ps 当外部命令执行时,会创建出一个子进程
-->内建命令 不需要使用子进程来执行 
-->使用 history 命令 
--->history -- 用过的命令 通常历史记录中会保存最近的1000条命令 
--->输入 !! ,然后按回车键就能够唤出刚刚用过的那条命令来使用
----> -a -- 强制将命令历史记录写入.bash_history文件
-->命令别名 允许你为常用的命令(及其参数)创建另一个名称
-->alias new_name = "cmd_name"
---> -p -- 查看当前可用的别名


Chapter 6
1.什么是环境变量
-->全局环境变量 对于shell会话和所有生成的子shell都是可见的
--->env  printenv  -- 查看全局变量
-->局部环境变量 只能在定义它们的进程中可见
--->set 会显示为某个特定进程设置的所有环境变量

2.设置用户定义变量
-->设置局部用户定义变量 
---> var_name=value 变量名、等号和值之间没有空格 如果在赋值表达式中加上了空格,bash shell就会把值当成一个单独的命令
-->设置全局环境变量
--->export var_name; 变量名前面不需要加 $ 
--->修改子shell中全局环境变量并不会影响到父shell中该变量的值

3.删除环境变量
--->unset var_name  -- 删除已经存在的环境变量 记住不要使用 $
--->在处理全局环境变量时,事情就有点棘手了。如果你是在子进程中删除了一个全局环境变量, 这只对子进程有效。该全局环境变量在父进程中依然可用。
--->如果要用到变量,使用 $ ;如果要操作变量,不使用 $

4.默认的 shell 环境变量

5.设置 PATH 环境变量
--->PATH=$PATH:/home/christine/Scripts -- 将目录加到 PATH 环境变量

6.定位系统环境变量
-->登录 shell
---> /etc/profile -- 统上默认的bash shell的主启动文件
---> $HOME/.bash_profile -- 
---> $HOME/.bashrc -- 
---> $HOME/.bash_login -- 
---> $HOME/.profile -- 
-->交互式 shell 进程
-->非交互式 shell -- 系统执行shell脚本时用的就是这种shell 
-->环境变量持久化 -- 最好是在/etc/profile.d目录中创建一个以.sh结尾的文件。把所有新的或修改过的全局环境变量设置放在这个文件中 在大多数发行版中,存储个人用户永久性bash shell变量的地方是$HOME/.bashrc文件

7.数组变量
--->my_set=(value1 value2 ..) -- 
--->echo ${my_set[num]} -- 引用一个单独的数组元素
--->echo ${my_set[*]} -- 显示整个数组变量
--->my_set[n]=new_value -- 改变某个索引值位置的值
--->unset my_set[n] -- 专门显示索引值为 n 的位置上的值时,就能看到这个位置是空的
--->unset my_set -- 删除整个数组
---->有时数组变量会让事情很麻烦,所以在shell脚本编程时并不常用
---->数组变量的可移植性并不好


Chapter 7
1.Linux 的安全性
--->核心是用户账户 每个能进入Linux系统的用户都会被分配唯一的用户账户。用户对系统中各种对象的访问权限取决于他们登录系统时用的账户。用户权限是通过创建用户时分配的用户ID(User ID,通常缩写为UID)来跟踪的
--> /etc/passwd 文件
--->将用户的登录名匹配到对应的UID值 密码字段都被设置成了x,这并不是说所有的用户账户都用相同的密码。安全 
-->/etc/shadow 文件 只有root用户才能访问/etc/shadow文件,这让它比起/etc/passwd安全许多。有加密后的用户密码
-->添加新用户
--->useradd 
----> -D -- 显示的那些默认值
----> -c comment 给新用户添加备注
----> -d home_dir 为主目录指定一个名字(如果不想用登录名作为主目录名的话)
----> -e expire_date
----> -f inactive_days 用YYYY-MM-DD格式指定一个账户过期的日期
----> 指定这个账户密码过期后多少天这个账户被禁用; 0 表示密码一过期就立即禁用, 1 表示
----> 禁用这个功能
----> -g initial_group 指定用户登录组的GID或组名
----> -G group ... 指定用户除登录组之外所属的一个或多个附加组
----> -k 必须和 -m 一起使用,将/etc/skel目录的内容复制到用户的HOME目录
----> -m 创建用户的HOME目录
----> -M 不创建用户的HOME目录(当默认设置里要求创建时才使用这个选项)
----> -n 创建一个与用户登录名同名的新组
----> -r 创建系统账户
----> -p passwd 为用户账户指定默认密码
----> -s shell 指定默认的登录shell
----> -u uid 为账户指定唯一的UID
--->在 -D 选项后跟上一个指定的值来修改系统默认的新用户设置。
----> -b default_home 更改默认的创建用户HOME目录的位置
----> -e expiration_date 更改默认的新账户的过期日期
----> -f inactive 更改默认的新用户从密码过期到账户被禁用的天数
----> -g group 更改默认的组名称或GID
----> -s shell 更改默认的登录shell
-->删除用户
--->userdel 删除/etc/passwd文件中的用户信息
----> -r -- 删除用户的HOME目录以及邮件目录
---->在有大量用户的环境中使用 -r 参数时要特别小心。你永远不知道用户是否在其HOME目录下存放了其他用户或其他程序要使用的重要文件。
-->修改用户
---> usermod  只需用与想修改的字段对应的命令行参数就可以了
---> -l 修改用户账户的登录名。
---> -L 锁定账户,使用户无法登录。
---> -p 修改账户的密码。
---> -U 解除锁定,使用户能够登录。
---> passwd 和 chpasswd 
----> passwd user_name
----> chpasswd < users.txt  你也可以用重定向命令来将含有 userid:passwd 对的文件重定向给该命令。
---> chsh 、 chfn 和 chage
----> chsh -s /bin/shell_name user_name  修改默认的用户登录shell
---->chfn user_name  会将用于Unix的 finger 命令的信息存进备注字段
---->chage 用来帮助管理用户账户的有效期  
-----> -d 设置上次修改密码到现在的天数
-----> -E 设置密码过期的日期
-----> -I 设置密码过期到锁定账户的天数
-----> -m 设置修改密码之间最少要多少天
-----> -W 设置密码过期前多久开始出现提醒信息
----->日期值  YYYY-MM-DD格式的日期 || 代表从1970年1月1日起到该日期天数的数值

2.使用 Linux 组
--->组权限允许多个用户对系统中的对象(比如文件、目录或设备等)共享一组共用的权限。
-->/etc/group 文件 
--->添加用户到一个组,要用 usermod 命令
-->创建新组
--->/usr/sbin/groupadd g_name
---->为用户账户分配组时要格外小心。如果加了 -g选项,指定的组名会替换掉该账户的默认组-G 选项则将该组添加到用户的属组的列表里,不会影响默认组。
-->修改组
--->groupmod [opt] g_name
----> -n 修改组名  groupmod -n new_name old_name
----> -g 修改GID 

3.理解文件权限
-->使用文件权限符
----> - 代表文件
----> d 代表目录
----> l 代表链接
----> c 代表字符型设备
----> b 代表块设备
----> n 代表网络设备
----> 之后有3组三字符的编码。每一组定义了3种访问权限:
----> r 代表对象是可读的
----> w 代表对象是可写的
----> x 代表对象是可执行的
----> 3组权限分别对应
----> 对象的属主
----> 对象的属组
----> 系统其他用户
-->默认文件权限 
--->unmask 0022  
---->第一位代表了一项特别的安全特性,叫作粘着位(sticky bit)。
---->后面的3位表示文件或目录对应的 umask 八进制值。rwx ---:0  rwx:7 
---->要把 umask 值从对象的全权限值中减掉。对目录来说,全权限的值是 666 (所有用户都有读
和写的权限);而对文件来说,则是 777 (所有用户都有读、写、执行权限)。
---->unmask dir_name 026   会从 777 中减去,留下来 751 作为目录权限设置。

4.改变安全性设置
-->改变权限
---> chmod options mode file //mode 参数可以使用八进制模式或符号模式进行安全性设置。八进制模式设置非常直观,直接用期望赋予文件的标准3位八进制权限码即可。
---->[ugoa...][[+-=][rwxXstugo...] // 符号模式
-->改变所属关系
--->chown options owner[.group] file -- 改变文件的属主
-->共享文件
--->方法是创建组


Chapter 8
1.探索 Linux 文件系统
-->基本的 Linux 文件系统
--->ext文件系统  -- 扩展文件系统 索引节点的系统来存放虚拟目录中所存储文件的信息
--->ext2文件系统 -- 第二代扩展文件系统 通过按组分配磁盘块来减轻碎片化
-->日志文件系统
---->先将文件的更改写入到临时文件(称作日志,journal)中。在数据成功写到存储设备和索引节点表之后,再删除对应的日志条目。
--->ext3文件系统  -- 采用和ext2文件系统相同的索引节点表结构,但给每个存储设备增加了一个日志文件 
--->ext4文件系统 -- 引入了块预分配技术
--->Reiser文件系统 -- 只把索引节点表数据写到日志文件
--->JFS文件系统 -- 有序日志方法 只在日志中保存索引节点表数据,直到真正的文件数据被写进存储设备时才删除它。
-->写时复制文件系统
---->COW -- 会使用克隆或可写快照。修改过的数据并不会直接覆盖当前数据,而是被放入文件系统中的另一个位置上。即便是数据修改已经完成,
--->ZFS文件系统 
--->Btrf文件系统 -- B树文件系统 

2.操作文件系统
-->创建分区
--->sudo fdisk /dev/sda  
----> -m -- for help 
--->partprob 或 hdparm 命令 要么重启系统 系统读取更新过的分区表
-->创建文件系统
---->要想知道某个文件系统工具是否可用,可以使用type 命令 type _name
--->sudo fs_name /dev/sda3 //your new part
--->sudo mount -t fs_name /dev/sda3 /home/iname/disk1 
--->-t 选项指明了要挂载的文件系统类型
---->这种挂载文件系统的方法只能临时挂载文件系统。当重启Linux系统时,文件系统并不会自动挂载。要强制Linux在启动时自动挂载新的文件系统,可以将其添加到/etc/fstab文件。
-->文件系统的检查与修复
--->fsck options filesystem -- 能够检查和修复大部分类型的Linux文件系统
---->只能在未挂载的文件系统上运行 fsck 命令

3.逻辑卷管理
---->logical volume manager,LVM
-->逻辑卷管理布局 -- 核心在于如何处理安装在系统上的硬盘分区
---->硬盘称作物理卷(physical volume,PV) 每个物理卷都会映射到硬盘上特定的物理分区。
---->多个物理卷集中在一起可以形成一个卷组(volume group,VG)逻辑卷管理系统将卷组视为一个物理硬盘
---->逻辑卷管理系统允许你将它添加到已有卷组,为某个已有的卷组创建更多空间,或是创建一个可用来挂载的新逻辑卷。
-->Linux 中的 LVM
---->version 
---->LVM1 -- 仅提供了基本的逻辑卷管理功能
---->LVM2 -- 除了标准的逻辑卷管理功能外,LVM2还提供了另外一些好用的功能。
----->快照 -- 允许你在逻辑卷在线的状态下将其复制到另一个设备 LVM1只允许你创建只读快照LVM2允许你创建在线逻辑卷的可读写快照
----->条带化 -- 可跨多个物理硬盘创建逻辑卷 
----->镜像 -- 镜像是一个实时更新的逻辑卷的完整副本。
-->使用 Linux LVM 
---->fdisk cmd  t
--->定义物理卷
---->sudo pvcreate /dev/sda1
--->创建卷组
---->sudo vgcreate Vol1 /dev/sdb1
---->sudo vgdisplay Vol1
--->创建逻辑卷
sudo lvcreate -l 100%FREE -n lvtest Vol1
--->创建文件系统
---->sudo mkfs.ext4 /dev/Vol1/lvtest
--->修改LVM
----> vgchange 激活和禁用卷组
----> vgremove 删除卷组
----> vgextend 将物理卷加到卷组中
----> vgreduce 从卷组中删除物理卷
----> lvextend 增加逻辑卷的大小
----> lvreduce 减小逻辑卷的大小


Chapter 9
---->管理系统(package management system,PMS)
1.包管理基础
2.基于 Debian 的系统
--->apt-get
--->apt-cache
--->aptitude -- 查看已安装了什么软件包  
---->aptitude search package_name -- 找到特定的软件包 名字之前都有一个 p 或 i 。如果看到一个 i ,说明这个包现在已经安装
---->aptitude install package_name -- 安装
---->aptitude safe-upgrade -- 更新
---->aptitude purge || remove software_name
----->要想只删除软件包而不删除数据和配置文件,可以使用 aptitude 的 remove 选项。要删除软件包和相关的数据和配置文件,可用 purge 选项。
---->aptitude 仓库

3.基于 Red Hat 的系统
--->yum :在Red Hat和Fedora中使用。
--->urpm :在Mandriva中使用。
--->zypper :在openSUSE中使用。
-->列出已安装包
--->yum list installed
-->用 yum 安装软件
--->yum install package_name
-->用 yum 更新软件
--->yum list updates
-->用 yum 卸载软件
--->yum remove || erase package_name -- 要删除软件和它所有的文件,就用 erase 选项
-->处理损坏的包依赖关系
--->yum clean all //先试试下面的命令
--->试着用 yum 命令的 update 选项
--->yum deplist package_name //显示了所有包的库依赖关系以及什么软件可以提供这些库依赖关系
--->yum update --skip-broken //允许你忽略依赖关系损坏的那个包
-->yum 软件仓库
--->yum repolist  //知道你现在正从哪些仓库中获取软件

4.从源码安装  -- tarball形式的软件 解包与安装过程
--->sysstat -- 提供了各种系统监测工具,非常好用  文件名是sysstat-11.1.1.tar.gz
--->tar -zxvf sysstat-11.1.1.tar.gz //完成解包,文件都放到sysstat-11.1.1的目录中
--->用 cd 命令进入这个新目录中,然后列出这个目录的内容
--->按照README文件中的建议,下一步是为系统配置sysstat
--->用 make 命令来构建各种二进制文件


Chapter 10
1.vim编辑器
---->vi是Unix系统最初的编辑器 vi improved,或vim
-->检查 vim 软件包
--->readlink -f file_path  // 立刻找出链接文件的最后一环
-->vim 基础
---->如在启动vim时未指定文件名,或者这个文件不存在,vim会开辟一段新的缓冲区域来编辑如果你在命令行下指定了一个已有文件的名字,vim会将文件的整个内容都读到一块缓冲区域来准备编辑,
--->两种操作模式
---->普通模式 -- 将按键解释成命令
-----> -- h :左移一个字符  -- j :下移一行(文本中的下一行) -- k :上移一行(文本中的上一行)--l :右移一个字符。
-----> -- PageDown (或Ctrl+F):下翻一屏 -- ageUp (或Ctrl+B):上翻一屏 -- G :移到缓冲区的最后一行 -- num G :移动到缓冲区中的第 num 行 -- gg :移到缓冲区的第一行
-----> -- q :如果未修改缓冲区数据,退出 -- q! :取消所有对缓冲区数据的修改并退出 -- w filename :将文件保存到另一个文件中 -- wq :将缓冲区数据保存到文件中并退出
-----> -- x 删除当前光标所在位置的字符
-----> dd 删除当前光标所在行
-----> dw 删除当前光标所在位置的单词
-----> d$ 删除当前光标所在位置至行尾的内容
-----> J 删除当前光标所在行行尾的换行符(拼接行)
-----> u 撤销前一编辑命令
-----> a 在当前光标后追加数据
-----> A 在当前光标所在行行尾追加数据
-----> r char 用 char 替换当前光标所在位置的单个字符
-----> R text 用 text 覆盖当前光标所在位置的数据,直到按下ESC键
-----> 有些编辑命令允许使用数字修饰符来指定重复该命令多少次。比如,命令 2x 会删除从光标当前位置开始的两个字符,命令 5dd 会删除从光标当前所在行开始的5行
----->剪切和粘贴
----->vim在删除数据时,实际上会将数据保存在单独的一个寄存器中。可以用 p 命令取回数据可以用dd 命令删除一行文本,然后把光标移动到缓冲区的某个要放置该行文本的位置,然后用 p 命令
----->复制和粘贴
-----> y  -- 可以在 y 后面使用和 d 命令相同的第二字符( yw 表示复制一个单词, y$ 表示复制到行尾)。在复制文本后,把光标移动到你想放置文本的地方,输入 p 命令。复制的文本就会出现在该位置
----->可视模式会在你移动光标时高亮显示文本。可以用可视模式选取要复制的文本。要进入可视模式,应移动光标到要开始复制的位置,并按下v键。你会注意到光标所在位置的文本已经被高亮显示了。下一步,移动光标来覆盖你想要复制的文本(甚至可以向下移动几行来复制更多行的文本)在移动光标时,vim会高亮显示复制区域的文本。在覆盖了要复制的文本后,按y键来激活复制命令。现在寄存器中已经有了要复制的文本,移动光标到你要放置的位置,使用 p 命令来粘贴
---->查找和替换
----->要输入一个查找字符串,就按下斜线(/)键。光标会跑到消息行,然后vim会显示出斜线。在输入你要查找的文本后,按下回车键
-----> 替换命令的格式 --  :s/old/new/
----->:s/old/new/g :一行命令替换所有 old 
----->:n,ms/old/new/g :替换行号 n 和 m 之间所有 old 
----->:%s/old/new/g :替换整个文件中的所有 old 
----->:%s/old/new/gc :替换整个文件中的所有 old ,但在每次出现时提示
---->插入模式 -- vim会将你在当前光标位置输入的每个键都插入到缓冲区

2.nano 编辑器
--->nano myprog.c   //脱字符(^)表示Ctrl键。因此, ^X 表示的就是组合键Ctrl+X

3.emacs编辑器
-->检查 emacs 软件包

4.KDE系编辑器
KWrite:单屏幕文本编辑程序
Kate:功能全面的多窗口文本编辑程序

5.GNOME编辑器
-->启动 gedit
--->gedit factorial.sh myprog.c


Chapter 11
1.使用多个命令
----> 将多个命令串起来 使用这种办法就能将任意多个命令串连在一起使用了,只要不超过最大命令行字符数255就行

2.创建 shell 脚本文件
--->#!/bin/bash  -- 在通常的shell脚本中,井号( # )用作注释行。shell并不会处理shell脚本中的注释行。然而,shell脚本文件的第一行是个例外, # 后面的惊叹号会告诉shell用哪个shell来运行脚本
---->让shell找到test1脚本 采取以下两种作法之一
---->将shell脚本文件所处的目录添加到 PATH 环境变量中;
---->在提示符中用绝对或相对文件路径来引用shell脚本文件。
---->chmod 命令 赋予文件属主执行文件的权限

3.显示消息
--->echo "string"|var  可用单引号或双引号来划定文本字符串
---->echo -n "will follow in this line " //文本字符串和命令输出显示在同一行中 在字符串的两侧使用引号,保证要显示的字符串尾部有一个空格

4.使用变量
-->环境变量
---->在环境变量名称之前加上美元符( $ )来使用这些环境变量
-->用户变量
---->var_name=value //assign  without $
---->echo $var_name //use  with $
-->命令替换
---->shell脚本中最有用的特性之一就是可以从命令输出中提取信息,并将其赋给变量。把输出赋
给变量之后,就可以随意在脚本中使用了。这个特性在处理脚本数据时尤为方便。
---->两种方法可以将命令输出赋给变量
---->反引号字符( ` )
----->要注意反引号字符,这可不是用于字符串的那个普通的单引号字符。由于在shell脚本之外很少用到,你可能甚至都不知道在键盘什么地方能找到这个字符。但你必须慢慢熟悉它,因为这是许多shell脚本中的重要组件。提示:在美式键盘上,它通常和波浪线(~)位于同一键位。
---->$() 格式
----->命令替换允许你将shell命令的输出赋给变量。尽管这看起来并不那么重要,但它却是脚本编程中的一个主要组成部分 要么用一对反引号把整个命令行命令围起来 testing='date' 要么使用 $() 格式:testing=$(date)  注意,赋值等号和命令替换字符之间没有空格。

5.重定向输入和输出
-->输出重定向  with > 
---> command > outputfile -- 最基本的重定向将命令的输出发送到一个文件中
-->输入重定向  with <
--->command < inputfile
---->一个简单的记忆方法就是:在命令行上,命令总是在左侧,而重定向符号“指向”数据流动的
方向
--->command << marker  另外一种输入重定向的方法,称为内联输入重定向(inline input redirection)。这种方法无需使用文件进行重定向,只需要在命令行中指定用于输入重定向的数据就可以了。

6.管道
---->有时需要将一个命令的输出作为另一个命令的输入。这可以用重定向来实现,只是有些笨拙。
---->command1 | command2  -- 第一个命令产生输出的同时,输出会被立即送给第二个命令
---->可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细
化操作

7.执行数学运算
-->expr 命令 expr var1 op var2
----> ARG1 | ARG2 如果 ARG1 既不是null也不是零值,返回 ARG1 ;否则返回 ARG2
----> ARG1 & ARG2 如果没有参数是null或零值,返回 ARG1 ;否则返回 0
----> ARG1 < ARG2 如果 ARG1 小于 ARG2 ,返回 1 ;否则返回 0
----> ARG1 <= ARG2 如果 ARG1 小于或等于 ARG2 ,返回 1 ;否则返回 0
----> ARG1 = ARG2 如果 ARG1 等于 ARG2 ,返回 1 ;否则返回 0
----> ARG1 != ARG2 如果 ARG1 不等于 ARG2 ,返回 1 ;否则返回 0
----> ARG1 >= ARG2 如果 ARG1 大于或等于 ARG2 ,返回 1 ;否则返回 0
----> ARG1 > ARG2 如果 ARG1 大于 ARG2 ,返回 1 ;否则返回 0
----> ARG1 + ARG2 返回 ARG1 和 ARG2 的算术运算和
----> ARG1 - ARG2 返回 ARG1 和 ARG2 的算术运算差
----> ARG1 * ARG2 返回 ARG1 和 ARG2 的算术乘积
----> ARG1 / ARG2 返回 ARG1 被 ARG2 除的算术商
----> ARG1 % ARG2 返回 ARG1 被 ARG2 除的算术余数
----> STRING : REGEXP 如果 REGEXP 匹配到了 STRING 中的某个模式,返回该模式匹配
----> match STRING REGEXP 如果 REGEXP 匹配到了 STRING 中的某个模式,返回该模式匹配
----> substr STRING POS LENGTH 返回起始位置为 POS (从 1 开始计数)、长度为 LENGTH 个字符的子字符串
----> index STRING CHARS 返回在 STRING 中找到 CHARS 字符串的位置;否则,返回 0
----> length STRING 返回字符串 STRING 的数值长度
----> + TOKEN 将 TOKEN 解释成字符串,即使是个关键字
----> (EXPRESSION) 返回 EXPRESSION 的值
---->对于那些容易被shell错误解释的字符,在它们传入 expr 命令之前,需要使用shell的转义字符(反斜线)将其标出来 expr 5 \* 2
---->要将一个数学算式的结果赋给一个变量,需要使用命令替换来获取 expr 命令的输出 var3=$(expr $var2 / $var1)
-->使用方括号
--->$[ operation ]
---->在使用方括号来计算公式时,不用担心shell会误解乘号或其他符号。shell知道它不是通配符
-->浮点解决方案 
---->内建的bash计算器 bc
--->bc 的基本用法
---->bash计算器实际上是一种编程语言,它允许在命令行中输入浮点表达式,然后解释并计算该
表达式,最后返回结果
---->能够识别: 数字(整数和浮点数) - 变量(简单变量和数组) -注释(以#或C语言中的 /* */ 开始的行) - 表达式 - 编程语句(例如 if-then 语句) - 函数 
----> 可以在shell提示符下通过 bc 命令访问bash计算器
---->浮点运算是由内建变量 scale 控制的。必须将这个值设置为你希望在计算结果中保留的小数
位数,否则无法得到期望的结果
-->在脚本中使用 bc
---->可以用命令替换运行 bc 命令,并将输出赋给一个变量
--->variable=$(echo "options; expression" | bc)
---->第一部分 options 允许你设置变量 如果你需要不止一个变量,可以用分号将其分开
---->在 expression 部分指定了特定的运算
---->bc 命令能识别输入重定向,允许你将一个文件重定向到 bc
---->最好的办法是使用内联输入重定向,它允许你直接在命令行中重定向数据 variable=$(bc << EOF options statements expressions EOF )

8.退出脚本
-->查看退出状态码
--->echo $?
---->按照惯例,一个成功结束的命令的退出状态码是 0 。如果一个命令结束时有错误,退出状态码就是一个正数值
----> 0 命令成功结束
----> 1 一般性未知错误
----> 2 不适合的shell命令
----> 126 命令不可执行
----> 127 没找到命令
----> 128 无效的退出参数
----> 128+x 与Linux信号x相关的严重错误
----> 130 通过Ctrl+C终止的命令
----> 255 正常范围之外的退出状态码
-->exit 命令
---->默认情况下,shell脚本会以脚本中的最后一个命令的退出状态码退出 你可以改变这种默认行为,返回自己的退出状态码 exit 命令允许你在脚本结束时指定一个退出状态码
--->exit state_code
---->退出状态码最大只能是 255 >255 被缩减到0~255的区间 shell通过模运算得到结果


Chapter 12
1.使用 if-then 语句
---->bash shell的 if 语句会运行 if 后面的那个命令。如果该命令的退出状态码(参见第11章)是 0(该命令成功运行),位于 then 部分的命令就会被执行。如果该命令的退出状态码是其他值, then 部分的命令就不会被执行
--->if command        --- if command; then
--->then              --- commands
--->     commands      --- fi
--->fi
-->if-then-else 语句
--->if command    --- if command; then
--->then          --- commands; else
---> commands     commands;
--->else          fi
---> commands
--->fi
-->嵌套 if
---->有时你需要检查脚本代码中的多种条件 对此,可以使用嵌套的 if-then 语句
----> elif 语句行提供了另一个要测试的命令,这类似于原始的 if 语句行

4.test 命令
---->test 命令提供了在 if-then 语句中测试不同条件的途径 如果 test 命令中列出的条件成立,test 命令就会退出并返回退出状态码 0  这样 if-then 语句就与其他编程语言中的 if-then 语句以类似的方式工作了 如果条件不成立, test 命令就会退出并返回非零的退出状态码,这使得if-then 语句不会再被执行 如果不写 test 命令的 condition 部分,它会以非零的退出状态码退出,并执行 else 语句块
--->test condition
--->if [ condition ]  -- bash shell提供了另一种条件测试方法 第一个方括号之后和第二个方括号之前必须加上一个空格,否则就会报错
-->数值比较 n1 -eq || -ge || -gt || -le || -lt || -ne  n2
-->字符串比较 str1 = || != || < || > str2   -n str1 长度!=0? -z str1 长度=0?
---->大于号和小于号必须转义
---->大于和小于顺序和 sort 命令所采用的不同 lowwer > upper  but in sort upr>lwr
-->文件比较
----> -d file 检查 file 是否存在并是一个目录
----> -e file 检查 file 是否存在
----> -f file 检查 file 是否存在并是一个文件
----> -r file 检查 file 是否存在并可读
----> -s file 检查 file 是否存在并非空
----> -w file 检查 file 是否存在并可写
----> -x file 检查 file 是否存在并可执行
----> -O file 检查 file 是否存在并属当前用户所有
----> -G file 检查 file 是否存在并且默认组与当前用户相同
----> file1 -nt file2 检查 file1 是否比 file2 新
----> file1 -ot file2 检查 file1 是否比 file2 旧

5.复合条件测试
-->if-then 语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用:
--->[ condition1 ] && [ condition2 ]
--->[ condition1 ] || [ condition2 ]

6.if-then 的高级特性
-->使用双括号  可以是任意的数学赋值或比较表达式
--->(( expression ))  //不需要将双括号中表达式里的大于号转义 这是双括号命令提供的另一个高级特性
-->使用双方括号
--->[[ expression ]]  //使用了 test 命令中采用的标准字符串比较 提供了模式匹配(pattern matching)  在模式匹配中,可以定义一个正则表达式  [[ str == s* ]]

7.case命令
--->case variable in
--->pattern1 | pattern2) commands1;;
--->pattern3) commands2;;
--->*) default commands;;
--->esac
---->case 命令会将指定的变量与不同模式进行比较。如果变量和模式是匹配的,那么shell会执行为该模式指定的命令。可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值。这里有个将 if-then-else 程序转换成用 case 命令的例子


Chapter 13
1.for命令
-->读取列表中的值
--->for var in list  //在 list 参数中,你需要提供迭代中要用到的一系列值
--->do         --- for var in list ; do 
--->  commands ---   commands;
--->done       --- done
---->var会一直保持最后一次迭代的值(除非你修改了它)
-->读取列表中的复杂值
--->有时会遇到难处理的数据  I don't know if this'll work
--->shell看到了列表值中的单引号并尝试使用它们来定义一个单独的数据值
--->使用转义字符(反斜线)来将单引号转义;
--->使用双引号来定义用到单引号的值
---->记住, for 循环假定每个值都是用空格分割的 如果有包含空格的数据值,你就陷入麻烦了
---->如果在单独的数据值中有空格,就必须用双引号将这些值圈起来 某个值两边使用双引号时,shell并不会将双引号当成值的一部分
-->从变量读取列表
--->var=$varstr //拼接  add str into var var = "n1" $var" n2" -->var="n1 n2" 
--->$var:n2 -->var="n1:n2"  
--->for name in $list ;do commands; done 
-->从命令读取值
---->用命令替换来执行任何能产生输出的命令,然后在 for 命令中使用该命令的输出。
-->更改字段分隔符
---->造成这个问题的原因是特殊的环境变量 IFS 内部字段分隔符(internal field separator)
默认情况下,bash shell会将下列字符当作字段分隔符: 空格 制表符 换行符
---->可以在shell脚本中临时更改 IFS 环境变量的值来限制被bash shell当作字段
---->ITF=$'\n'
---->在处理代码量较大的脚本时,可能在一个地方需要修改 IFS 的值,然后忽略这次修改,在脚本的其他地方继续沿用 IFS 的默认值 IFS.OLD=$IFS  IFS=$'\n'<在代码中使用新的IFS值>IFS=$IFS.OLD
-->用通配符读取目录
---->可以用 for 命令来自动遍历目录中的文件  for file in /home/rich/test/*
---->目录名和文件名中包含空格当然是合法的。要适应这种情况,应该将 $file 变量用双引号圈起来

2.C 语言风格的 for 命令
-->C 语言的 for 命令
--->for (int i=0;i<3;i++){}
--->C语言风格的 for 命令看起来如下 for (( a = 1; a < 10; a++ )); do commands; done
-->使用多个变量 for (( a=1, b=10; a <= 10; a++, b-- ))
--->e.g for (( a=1, b=10; a <= 10; a++, b-- ));do echo "$a-$b" ; done
 
3.while 命令
-->while 的基本格式 while test condition ; do commands; done
---->while 命令允许你在 while 语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环 在含有多个命令的 while 语句中,在每次迭代中所有的测试命令都会被执行,包括测试命令失败的最后一次迭代

4.until 命令
-->until test commands ; do commands; done
---->shell会执行指定的多个测试命令,只有在最后一个命令成立时停止

5.嵌套循环
---->循环语句可以在循环内使用任意类型的命令,包括其他循环命令。这种循环叫作嵌套循环

6.循环处理文件数据
---->使用嵌套循环
---->修改 IFS 环境变量
----->通过修改 IFS 环境变量,就能强制 for 命令将文件中的每行都当成单独的一个条目来处理,即便数据中有空格也是如此。一旦从文件中提取出了单独的行,可能需要再次利用循环来提取行中的数据
---->input.txt
---->a:v1
---->b:v2
---->c:v3
--->IFS.OLD=$IFS
--->IFS=$'\n'
--->for entry in $(cat input.txt)
--->do
--->echo "key \t value"
--->IFS=:
--->for value in $entry
--->do
--->echo "$value \t"
--->done
--->done

7.控制循环
-->break 命令  可以用 break 命令来退出任意类型的循环
--->跳出单个循环 
--->跳出内部循环
-->continue 命令
--->可以提前中止某次循环中的命令,但并不会完全终止整个循环
--->它会跳过剩余的命令。如果你在其中某个条件里对测试条件变量进行增值,问题就会出现

8.处理循环的输出
---->在shell脚本中,你可以对循环的输出使用管道或进行重定向。这可以通过在 done 命令之
后添加一个处理命令来实现 for ((  )) ; do commands ; done > f  || |cmd || < f

9.实例
-->查找可执行文件
--->    IFS=:
--->    for folder in $PATH
--->    do
--->        echo "$folder:"
--->        for file in $folder/*
--->        do
--->            if [ -x $file ]
--->            then
--->            echo "$file"
--->            fi
--->        done
--->    done
-->创建多个用户账户
---->while IFS=’,’ read –r userid name 


Chapter 14
1.命令行参数
---->向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据  ./addem 10 30
-->读取参数
---->bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的所有参数 位置参数变量是标准的数字: $0 是程序名, $1 是第一个参数, $2 是第二个参数,依次类推,直到第九个参数 $9
---->可以在shell脚本中像使用其他变量一样使用 $1 变量。shell脚本会自动将命令行参数的值分配给变量,不需要你作任何处理
---->如果脚本需要的命令行参数不止9个,你仍然可以处理,但是需要稍微修改一下变量名 在第9个变量之后,你必须在变量数字周围加上花括号,比如 ${10} 下面是一个这样的例子
-->读取脚本名 
---->可以用 $0 参数获取shell在命令行启动的脚本名
--->basename 命令会返回不包含路径的脚本名
-->测试参数
---> if [ -n "$var_name" ]  //使用参数前一定要检查其中是否存在数据

2.特殊参数变量
-->参数统计 
--->特殊变量$#含有脚本运行时携带的命令行参数个数 可以在脚本中任何地方使用这个特殊变量
--->if-then 语句用 -ne 测试命令行参数数量。如果参数数量不对,会显示一条错误消息告知脚本的正确用法
--->${$#} --invalid  ${!#} --valid  last paramete
-->抓取所有的数据
--->$* 和 $@ 变量可以用来轻松访问所有的参数
---->$* 变量会将命令行上提供的所有参数当作一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上 $* 变量会将这些参数视为一个整体,而不是多个个体
---->$@ 变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。这样你就能够遍历所有的参数值,得到每个参数。这通常通过 for 命令完成。

3.移动变量
--->shift 能够用来操作命令行参数  默认情况下它会将每个参数变量向左移动一个位置。所以,变量 $3的值会移到 $2 中,变量 $2 的值会移到 $1 中,而变量 $1 的值则会被删除
--->echo "Parameter #$count = $1" count=$[ $count + 1 ] shift

4.处理选项
-->查找选项
--->处理简单选项  用 case 语句(参见第12章)来判断某个参数是否为选项
--->分离参数和选项  Linux中处理这个问题的标准方式是用特殊字符来将二者分开,该字符会告诉脚本何时选项结束以及普通参数何时开始 对Linux来说,这个特殊字符是双破折线( -- )  在遇到双破折线时,脚本用 break 命令来跳出 while 循环。由于过早地跳出了循环,我们需要再加一条shift 命令来将双破折线移出参数变量。
--->处理带值的选项  case "$1" in -a) echo "Found the -a option";;                  -b)param="$2" ;echo "Found the -b option, with parameter value $param" ;shift ;;
-->使用 getopt 命令 
--->getopt optstring parameters
---->optstring 是这个过程的关键所在。它定义了命令行有效的选项字母,还定义了哪些选项字母需要参数值 首先,在 optstring 中列出你要在脚本中用到的每个命令行选项字母。然后,在每个需要参数值的选项字母后加一个冒号。 getopt 命令会基于你定义的 optstring 解析提供的参数。
--->getopt ab:cd -a -b test1 -cd test2 test3
  -> -a -b test1 -c -d -- test2 test3
---->optstring 定义了四个有效选项字母: a 、 b 、 c 和 d 。冒号( : )被放在了字母 b 后面,因为 b选项需要一个参数值。当 getopt 命令运行时,它会检查提供的参数列表(-a -b test1 -cd test2 test3 ) 并基于提供的 optstring 进行解析。
---->如果指定了一个不在 optstring 中的选项,默认情况下, getopt 命令会产生一条错误消息
---->如果想忽略这条错误消息,可以在命令后加 -q 选项 getopt 命令选项必须出现optstring 之前
-->在脚本中使用 getopt
---->用 getopt 命令生成的格式化后的版本来替换已有的命令行选项和参数 用 set 命令能够做到
---->set 命令的选项之一是双破折线( -- ) 它会将命令行参数替换成 set 命令的命令行值 然后,该方法会将原始脚本的命令行参数传给 getopt 命令,之后再将 getopt 命令的输出传给 set命令,用 getopt 格式化后的命令行参数来替换原始的命令行参数,看起来如下所示
--->set -- $(getopt -q ab:cd "$@")
---->getopt 命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符,而不是根据双引号将二者当作一个参数
-->使用更高级的 getopts
---->getopts 命令(注意是复数)内建于bash shell。它跟近亲 getopt 看起来很像,但多了一些扩展功能每次调用它时,它一次只处理命令行上检测到的一个参数。处理完所有的参数后,它会退出并返回一个大于0的退出状态码。这让它非常适合用解析命令行所有参数的循环中。
--->getopts optstring variable  
--->usage : while getopts optstring var ; do <something with var orOPTARG> ; done
---->要去掉错误消息的话,可以在 optstring 之前加一个冒号
---->getopts 命令将当前参数保存在命令行中定义的 variable 中
---->如果选项需要跟一个参数值, OPTARG 环境变量就会保存这个值 OPTIND 环境变量保存了参数列表中 getopts 正在处理的参数位置
---->getopts 命令解析命令行选项时会移除开头的单破折线,所以在 case 定义中不用单破折线
---->另一个好用的功能是将选项字母和参数值放在一起使用,而不用加空格
---->在 getopts 处理每个选项时,它会将 OPTIND 环境变量值增一。在 getopts 完成处理时,可以使用 shift 命令和 OPTIND 值来移动参数
---> shift $[ $OPTIND - 1 ] // $OPTIND point to first parameter  this command remove all opt who's index < $OPTIND make $1 = $OPTIND

5.将选项标准化
---->有些字母选项在Linux世界里已经拥有了某种程度的标准含义
----> -a  显示所有对象
----> -c  生成一个计数
----> -d  指定一个目录
----> -e  扩展一个对象
----> -f  指定读入数据的文件
----> -h  显示命令的帮助信息
----> -i  忽略文本大小写  
----> -l  产生输出的长格式版本
----> -n  使用非交互模式(批处理)
----> -o  将所有输出重定向到的指定的输出文件
----> -q  以安静模式运行
----> -r  递归地处理目录和文件
----> -s  生成详细输出
----> -v
----> -x  排除某个对象
----> -y  对所有问题回答yes

6.获得用户输入
--->read 
-->基本的读取 
---->read 命令从标准输入(键盘)或另一个文件描述符中接受输入。在收到输入后, read 命令会将数据放进一个变量
---->如果变量数量不够,剩下的数据就全部分配给最后一个变量
---->如果不指定变量, read 命令会将它收到的任何数据都放进特殊环境变量 REPLY 中。
----> -t 选项来指定一个计时器秒数  当计时器过期后, read 命令会返回一个非零退出状态码
----> -s 隐藏方式读取 会将文本颜色设成跟背景色一样
---->read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]
-->从文件中读取
---->每次调用 read 命令,它都会从文件中读取一行文本。当文件中再没有内容时 read 命令会退出并返回非零退出状态码
---->最常见的方法是对文件使用 cat 命令,将结果通过管道直接传给含有 read 命令的 while 命令
---> cat input.txt | while read line ; do commands ; done


Chapter 15
1.理解输入和输出
-->标准文件描述符
----> 0  STDIN   标准输入
----> 1  STDOUT  标准输出
----> 2  STDERR  标准错误
--->STDIN
---->对终端界面来说,标准输入是键盘对终端界面来说,标准输入是键盘
---->使用输入重定向符号( < )时,Linux会用重定向指定的文件来替换标准输入文件描述符
---->可以使用这种技术将数据输入到任何能从STDIN 接受数据的shell命令中
--->STDOUT
---->在终端界面上,标准输出就是终端显示器
---->通过输出重定向符号,通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件
---->你也可以将数据追加到某个文件。这可以用 >> 符号来完成
--->STDERR
---->默认情况下, STDERR 文件描述符会和 STDOUT 文件描述符指向同样的地方
---->TDERR 并不会随着 STDOUT 的重定向而发生改变
-->重定向错误
--->只重定向错误  
---->e.g  ls -al badfile 2> test4  只重定向错误消息,而非普通数据
---->将该文件描述符值紧紧地放在重定向符号前 
--->重定向错误和数据
---->e.g  ls -al test test2 test3 badtest 2> test6 1> test7
---->如果想重定向错误和正常输出,必须用两个重定向符号 符号前面放文件描述符 指向输出文件
----> &> test7  将 STDERR 和 STDOUT 的输出重定向到同一个输出文件 also can use &>> f
----> 为了避免错误信息散落在输出文件中 shell自动赋予了错误消息更高的优先级

2.在脚本中重定向输出
---->可以在脚本中用 STDOUT 和 STDERR 文件描述符以在多个位置生成输出 
-->临时重定向
--->echo "This is an error message" >&2
---->如果有意在脚本中生成错误消息,可以将单独的一行输出重定向到 STDERR  
---->如果你在运行脚本时重定向了STDERR ,脚本中所有导向 STDERR 的文本都会被重定向
-->永久重定向脚本中的所有命令
---> exec 1>f1    exec 2>f2
---->可以用 exec 命令告诉shell在脚本执行期间重定向某个特定文件描述符
---->尽管 STDOUT 被重定向了,但你仍然可以将 echo 语句的输出发给 STDERR

3.在脚本中重定向输入
--->exec 0< testfile  个命令会告诉shell它应该从文件 testfile 中获得输入,而不是 STDIN
---->when read line from file  you can echo it to another file and then change  
---->IFS to decode the line  don't forget to change back the IFS
---> while read line ; do echo line > tempfile ; IFS_OLD=$IFS;IFS=$':';<decode>;IFS=$IFS_OLD;done

4.创建自己的重定向
--->有9个打开的文件描述符 其他6个从 3 ~ 8 的文件描述符均可用作输入或输出重定向
-->创建输出文件描述符 
--->e.g  exec 3>testfile  echo "something " >&3 用 exec 命令将文件描述符 3 重定向到另一个文件  重定向到文件描述符 3 的那行 echo 语句的输出却进入了另一个文件  这样你就可以在显示器上保持正常的输出 而将特定信息重定向到文件中
-->重定向文件描述符
--->临时重定向 exec 3>&1  exec 1>tempfile  exec 1>&3
-->创建输入文件描述符
---->可以用和重定向输出文件描述符同样的办法重定向输入文件描述符
---> exec 6<&0  exec 0<tempfile  exec 0<&6
-->创建读写文件描述符
---->可以打开单个文件描述符来作为输入和输出
---->小心文件指针 覆盖
-->关闭文件描述符
--->exec 3>&-  该语句会关闭文件描述符 3 ,不再在脚本中使用它
--->在关闭文件描述符时还要注意 如果随后你在脚本中打开了同一个输出文件,shell会用一个新文件来替换已有文件

5.列出打开的文件描述符
---->lsof 命令会列出整个Linux系统打开的所有文件描述符 鉴于它会向非系统管理员用户提供Linux系统的信息 许多Linux系统隐藏了该命令 
---->在很多Linux系统中(如Fedora), lsof 命令位于/usr/sbin目录 要想以普通用户账户来运行
它,必须通过全路径名来引用:$ /usr/sbin/lsof
---->它会显示当前Linux系统上打开的每个文件的有关信息 包括后台运行的所有进程以及登录到系统的任何用户
---->有大量的命令行选项和参数可以用来帮助过滤 lsof 的输出。最常用的有 -p 和 -d ,前者允许
指定进程ID(PID) 后者允许指定要显示的文件描述符编号
---->要想知道进程的当前PID,可以用特殊环境变量 $$ (shell会将它设为当前PID)
---->-a 选项用来对其他两个选项的结果执行布尔 AND 运算
--->e.g  /usr/sbin/lsof -a -p $$ -d0,1,2,3,6,7

6.阻止命令输出
---->可以将 STDERR 重定向到一个叫作null文件的特殊文件 shell输出到null文件的任何数据都不会保存,全部都被丢掉了  标准位置是/dev/null
---->也可以在输入重定向中将/dev/null作为输入文件。由于/dev/null文件不含有任何内容,程序员
通常用它来快速清除现有文件中的数据  cat /dev/null > testfile

7.创建临时文件
---->Linux使用/tmp目录来存放不需要永久保留的文件 大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件
-->创建本地临时文件  
---->默认情况下, mktemp 会在本地目录中创建一个文件
--->mktemp testing.XXXXXX   tempfile=$(mktemp test19.XXXXXX)
---->mktemp 命令可以在/tmp目录中创建一个唯一的临时文件
-->在/tmp 目录创建临时文件
---->-t 选项会强制 mktemp 命令来在系统的临时目录来创建该文件  在用这个特性时, mktemp 命
令会返回用来创建临时文件的全路径,而不是只有文件名
-->创建临时目录
---->-d 选项告诉 mktemp 命令来创建一个临时目录而不是临时文件 这样你就能用该目录进行任
何需要的操作了,比如创建其他的临时文件
---->tempdir=$(mktemp -d dir.XXXXXX)  cd $tempdir tempfile1=$(mktemp temp.XXXXXX)

8.记录消息
----> 用特殊的 tee 命令 将输出同时发送到显示器和日志文件,这种做法有时候能够派上用场
----> tee 命令相当于管道的一个T型接头 它将从 STDIN 过来的数据同时发往两处
--->e.g date | tee filename 
----> -a 将数据追加到文件中
---->默认情况下, tee 命令会在每次使用时覆盖输出文件内容

9.实例
--->cat >> $outfile << EOF INSERT INTO members (lname,fname,address,city,state,zip) VALUES ('$lname', '$fname', '$address', '$city', '$state', '$zip'); EOF


Chapter 16
1.处理信号
-->重温 Linux 信号
----> 1 SIGHUP 挂起进程
----> 2 SIGINT 终止进程
----> 3 SIGQUIT 停止进程
----> 9 SIGKILL 无条件终止进程
----> 15 SIGTERM 尽可能终止进程
----> 17 SIGSTOP 无条件停止进程,但不是终止进程
----> 18 SIGTSTP 停止或暂停进程,但不终止进程
----> 19 SIGCONT 继续运行停止的进程
-->生成信号
---->bash shell允许用键盘上的组合键生成两种基本的Linux信号
--->中断进程 Ctrl+C组合键 ^C 会生成 SIGINT 信号
--->暂停进程 Ctrl+Z组合键 ^Z 会生成一个 SIGTSTP 信号
-->捕获信号
--->trap commands signals 
--->e.g  trap "echo ' Sorry! I have trapped Ctrl-C'" SIGINT
---->如果脚本收到了 trap 命令中列出的信号,该信号不再由shell处理,而是交由本地处理。
---->本例中用到的 trap 命令会在每次检测到 SIGINT 信号时显示一行简单的文本消息
---->在 trap 命令行上,你只要列出想要shell执行的命令,以及一组用空格分开的待捕获的信号。你可以用数值或Linux信号名来指定信号。
-->捕获脚本退出
---> trap "echo ' Goodbye...'" EXIT
---->要捕获shell脚本的退出,只要在 trap 命令后加上 EXIT 信号就行
---->如果提前退出脚本,同样能够捕获到 EXIT 
-->修改或移除捕获
---->要想在脚本中的不同位置进行不同的捕获处理,只需重新使用带有新选项的 trap 命令
---->了信号捕获之后,脚本处理信号的方式就会发生变化
---->但如果一个信号是在捕获被修改前接收到的,那么脚本仍然会根据最初的 trap 命令进行处理。
--->trap -- SIGINT   可以删除已设置好的捕获

2.以后台模式运行脚本
-->后台运行脚本 -- 以后台模式运行shell脚本非常简单。只要在命令后加个 & 符就行了
--->e.g ./test5.sh &
---->最好是将后台运行的脚本的 STDOUT 和 STDERR  进行重定向,避免这种杂乱的输出。
-->运行多个后台作业
---->可以在命令行提示符下同时启动多个后台作业 
---->每次启动新作业时,Linux系统都会为其分配一个新的作业号和PID

3.在非控制台下运行脚本
--->nohup 运行了另外一个命令来阻断所有发送给该进程的 SIGHUP 信号
--->e.g nohup cmd & 
---->为了保存该命令产生的输出, nohup 命令会自动将 STDOUT 和 STDERR 的消息重定向到一个名为nohup.out的文件中  当运行位于同一个目录中的多个命令时一定要当心,因为所有的输出都会被发送到同一个nohup.out文件中,结果会让人摸不清头脑

4.作业控制
-->查看作业
--->jobs 允许查看shell当前正在处理的作业
---->你可能注意到了 jobs 命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用作业控制命令时,如果未在命令行指定任何作业号,该作业会被当成作业控制命令的操作对象
---->当前的默认作业完成处理后,带减号的作业成为下一个默认作业 任何时候都只有一个带加号的作业和一个带减号的作业,不管shell中有多少个正在运行的作业
----> -l  查看作业的PID   -n 只列出上次shell发出的通知后改变了状态的作业 
----> -p 只列出作业的PID  -r 只列出运行中的作业  -s 只列出已停止的作业
-->重启停止的作业
--->要以后台模式重启一个作业,可用 bg 命令加上作业号
--->要以前台模式重启作业,可用带有作业号的 fg 命令


5.调整谦让度
---->在多任务操作系统中(Linux就是),内核负责将CPU时间分配给系统上运行的每个进程
---->调度优先级是个整数值,从20(最高优先级)到+19(最低优先级) 默认情况下,bash shell
以优先级0来启动所有进程
-->nice 命令   
---->必须将 nice 命令和要启动的命令放在同一行中
---->要让命令以更低的优先级运行,只要用 nice的 -n 命令行来指定新的优先级级别
---->nice 命令的 -n 选项并不是必须的,只需要在破折号后面跟上优先级就行了
-->renice 命令
---> renice -n num -p pid
---->只能对属于你的进程执行 renice 
---->只能通过 renice 降低进程的优先级
---->root用户可以通过 renice 来任意调整进程的优先级

6.定时运行作业
-->用 at 命令来计划执行作业
---> at [-f filename] time
---->默认情况下, at 命令会将 STDIN 的输入放到队列中。你可以用 -f 参数来指定用于读取命令(脚本文件)的文件名
---->time 参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过, at 命令会在第二天的那个时间运行指定的作业
----> at 命令能识别多种不同的时间格式 --比如10:15  --比如10:15 PM  
----> --比如now、noon、midnight或者teatime  --比如MMDDYY、MM/DD/YY或DD.MM.YY
----> --比如Jul 4或Dec 25  --也可以指定时间增量 当前时间+25 min 明天10:15 PM
----> 作业队列的字母排序越高,作业运行的优先级就越低 默认提交到 a作业队列 
----> 如果想以更高优先级运行作业,可以用 -q 参数指定不同的队列字母
--->获取作业的输出
---->当作业在Linux系统上运行时,显示器并不会关联到该作业。取而代之的是,Linux系统会将提交该作业的用户的电子邮件地址作为 STDOUT 和 STDERR 。任何发到 STDOUT 或 STDERR 的输出都会通过邮件系统发送给该用户
-->安排需要定期执行的脚本  
---> cron时间表  
----> min hour dayofmonth month dayofweek command
---->cron时间表允许你用特定值、取值范围(比如1~5)或者是通配符(星号)来指定条目。例如,如果想在每天的10:15运行一个命令,可以用cron时间表条目
--->e.g 15 10 * * * command   想在每天的10:15运行一个命令
--->e.g 15 16 * * 1 command   要指定在每周一4:15 PM运行的命令
--->e.g 00 12 1 * * command   在每个月的第一天中午12点执行命令
---->加一条使用 date 命令的 if-then 语句来检查明天的日期是不是01:
----> 00 12 * * * if [ ` date +%d -d tomorrow ` = 01 ] ; then ; command
---> 构建cron时间表
----> Linux提供了 crontab 命令来处理cron时间表
----> -l 要列出已有的cron时间表
----> -e 为cron时间表添加条目
---> 浏览cron目录
----> 如果你创建的脚本对精确的执行时间要求不高,用预配置的cron脚本目录会更方便。有4个基本目录:hourly、daily、monthly和weekly  /etc/cron.hourly
-->anacron程序
----> 如果anacron知道某个作业错过了执行时间,它会尽快运行该作业
----> 这个功能常用于进行常规日志维护的脚本
---->anacron时间表的基本格式和cron时间表略有不同  
--->period delay identifier command  
----> period条目定义了作业多久运行一次 以天为单位  
---->delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本
---->identifier条目是一种特别的非空字符串,如 cron-weekly 。它用于唯一标识日志消息和错误邮件中的作业
---->command条目包含了run-parts程序和一个cron脚本目录名

7.使用新 shell 启动脚本
---->$HOME/.bash_profile
---->因此,应该将需要在登录时运行的脚本放在上面第一个文件中


Chapter 17
1.基本的脚本函数
--> 创建函数
--->两种格式
----> function name { commands }
----> name() { commands }
-->使用函数
----> 要在脚本中使用函数,只需要像其他shell命令一样,在行中指定函数名就行了
--->function fname { }   use: fname 
----> 如果在函数被定义前使用函数,你会收到一条错误消息
---->函数名必须是唯一的 定义了函数, 新定义会覆盖原来函数的定义

2.返回值
-->默认退出状态码
----> 默认情况下,函数的退出状态码是函数中最后一条命令返回的退出状态码
----> 在函数执行结束后 可以用标准变量 $? 来确定函数的退出状态码
--->e.g func1 ; echo "The exit status is: $?"
-->使用 return 命令
---> return state_code
----> 记住,函数一结束就取返回值
----> 记住,退出状态码必须是0~255
---->如果在用 $? 变量提取函数返回值之前执行了其他命令,函数的返回值就会丢失
---->记住, $?变量会返回执行的最后一条命令的退出状态码
-->使用函数输出
---->正如可以将命令的输出保存到shell变量中一样,你也可以对函数的输出采用同样的处理办法
---> res=`fname`  || res=$(fname) 
---->bash shell脚本忽略read输出 不将其作为 STDOUT的一部分

3.在函数中使用变量
--> 向函数传递参数
----> 函数可以使用标准的参数环境变量来表示命令行上传给函数的参数 
---->$0  $1-9 $# -- num of parameter  $* -- save as one word  $@ ${>9}
--> 在函数中处理变量
----> 函数中定义的变量与普通变量的作用域不同
----> 两种类型的变量 全局变量 局部变量
---> 全局变量  
----> 默认情况下,你在脚本中定义的任何变量 在函数外定义的变量可在函数内正常访问
----> 如果outer变量在函数内被赋予了新值,那么在脚本中引用该变量时,新值也依然有效
---> 局部变量 local var_name
---->local 关键字保证了变量只局限在该函数中
---->如果脚本中在该函数之外有同样名字的变量,那么shell将会保持这两个变量的值是分离的
---->现在你就能很轻松地将函数变量和脚本变量隔离开了,只共享需要共享的变量。

4.向函数传数组参数
--> 向函数传数组参数
----> 将数组变量当作单个参数传递的话,它不会起作用
----> 如果你试图将该数组变量作为函数参数,函数只会取数组变量的第一个值
----> 要解决这个问题,你必须将该数组变量的值分解成单个的值,然后将这些值作为函数参数使用
----> 在函数内部,可以将所有的参数重新组合成一个新的变量
---> myarray=(1 2 3 4 5)  testit ${myarray[*]}  
---> in testit --  local newarray=(;'echo "$@"')  use -- for v in ${newarray[*]}
--> 从函数返回数组
----> 从函数里向shell脚本传回数组变量也用类似的方法
----> 函数用 echo 语句来按正确顺序输出,然后脚本再将它们重新放进一个新的数组变量中
---> in function -- echo ${newarray[*]}
---> outer -- arg1=$(echo ${myarray[*]})   result=($(arraydblr $arg1))

5.函数递归
----> 局部函数变量的一个特性是自成体系
----> 除了从脚本命令行处获得的变量,自成体系的函数不需要使用任何外部资源
----> 这个特性使得函数可以递归地调用,也就是说,函数可以调用自己来得到结果

6.创建库
----> bash shell允许创建函数库文件,然后在多个脚本中引用该库文件
----> 使用函数库的关键在于 source 命令 source 命令会在当前shell上下文中执行命令
----> source 命令有个快捷的别名,称作点操作符(dot operator) source ./myfuncs
----> 要在shell脚本中运行myfuncs库文件,只需添加下面这行:. ./myfuncs  first . ==sorce
----> 这个例子假定myfuncs库文件和shell脚本位于同一目录

7.在命令行上使用函数
--> 在命令行上创建函数
----> 因为shell会解释用户输入的命令,所以可以在命令行上直接定义一个函数
----> 两种方法
----> 单行方式 function fname { commands; }  必须记得在每个命令后面加个分号
----> 多行方式 不用在每条命令的末尾放一个分号,只要按下回车键就行
----> 如果你给函数起了个跟内建命令或另一个命令相同的名字,函数将会覆盖原来的命令
--> 在.bashrc 文件中定义函数
----> 在命令行上直接定义shell函数的明显缺点是退出shell时,函数就消失了 对于复杂的函数来说,这可是个麻烦事 一个非常简单的方法是将函数定义在一个特定的位置 这个位置在每次启动一个新shell的时候,都会由shell重新载入 最佳地点就是.bashrc文件
---> 直接定义函数 可以直接在主目录下的.bashrc文件中定义函数 把你写的函数放在文件末尾就行了
---> 读取函数文件 
----> 只要是在shell脚本中,都可以用 source 命令(或者它的别名点操作符)将库文件中的函数
添加到你的.bashrc脚本中

8.实例  GNU shtool shell脚本函数库
--> 下载及安装
----> ftp://ftp.gnu.org/gnu/shtool/shtool-2.0.8.tar.gz  将文件复制到主目录中
----> tar -zxvf shtool-2.0.8.tar.gz
--> 构建库
----> ./confifgure
----> make
--> shtool 库函数
--> 使用库   shtool platform


Chapter 18
1.创建文本菜单
--> 创建菜单布局
----> clear;  echo -e "1.\tDisplay disk space" 
----> 要在 echo 命令中包含这些字符(比如制表符和换行符),必须用 -e 选项
----> read -n 1 option  用了 -n 选项来限制只读取一个字符
--> 创建菜单函数
----> shell脚本菜单选项作为一组独立的函数实现起来更为容易
--> 添加菜单逻辑
--> 整合 shell 脚本菜单
----> can use break to break while  --  while [] ; case x in t)break;;
--> 使用 select 命令
----> select 命令只需要一条命令就可以创建出菜单,然后获取输入的答案并自动处理
----> list 参数是由空格分隔的文本选项列表,这些列表构成了整个菜单
----> 为选项显示一个由 PS3 环境变量定义的特殊提示符
---> select variable in list  -- select 语句中的所有内容必须作为一行出现
---> do
---> commands  about variable  -- 存储在变量中的结果值是整个文本字符串 而不是数字
---> done

2.制作窗口
----> dialog 
--> dialog包
----> 使用命令行参数来决定生成哪种窗口部件 
----> 要在命令行上指定某个特定的部件,需使用双破折线格式 dialog --widget parameters
----> widget 是表18-1中的部件名  parameters 定义了部件窗口的大小以及部件需要的文本
----> 提供了两种形式的输出 --使用 STDERR   --使用退出状态码
----> 可以通过 dialog 命令的退出状态码来确定用户选择的按钮
----> 选择了Yes或OK按钮 返回退出状态码 0  
----> 如果选择了Cancel或No按钮, dialog 命令会返回退出状态码 1
----> calendar 提供选择日期的日历  checklist 显示多个选项(其中每个选项都能打开或关闭)
----> form 构建一个带有标签以及文本字段(可以填写内容)的表单
----> fselect 提供一个文件选择窗口来浏览选择文件
----> gauge 显示完成的百分比进度条 infobox 显示一条消息,但不用等待回应
----> inputbox 提供一个输入文本用的文本表单  inputmenu 提供一个可编辑的菜单
----> menu 显示可选择的一系列选项 msgbox 显示一条消息,并要求用户选择OK按钮
----> pause 显示一个进度条来显示暂定期间的状态 
----> passwordbox 显示一个文本框,但会隐藏输入的文本
----> passwordform 显示一个带标签和隐藏文本字段的表单
----> radiolist 提供一组菜单选项,但只能选择其中一个
----> tailbox 用tail命令在滚动窗口中显示文件的内容--
----> tailboxbg 跟tailbox一样,但是在后台模式中运行
----> textbox 在滚动窗口中显示文件的内容
----> timebox 提供一个选择小时、分钟和秒数的窗口
----> yesno 提供一条带有Yes和No按钮的简单消息
---> msgbox 部件   dialog --msgbox text height width
----> 它会在窗口中显示一条简单的消息,直到用户单击OK按钮后才消失
---> yesno 部件  
---->e.g dialog --title "Please answer" --yesno "Is this thing on?" 10 20
----> yesno 部件进一步扩展了msgbox部件的功能,允许用户对窗口中显示的问题选择yes或no  
---> inputbox 部件  dialog --inputbox "Enter your age:" 10 20 2>age.txt
----> dialog 命令会将文本字符串的值发给 STDERR 你必须重定向 STDERR 来获取用户输入
---> textbox 部件  e.g  dialog --textbox /etc/passwd 15 45
----> textbox 是显示大量信息的极佳办法 生成一个滚动窗口显示由参数所指定的文件中的文本
---> menu 部件
----> menu 部件允许你来创建我们之前所制作的文本菜单的窗口版本
----> 只要为每个选项提供一个选择标号和文本就行了
----> e.g dialog --menu "m_name" 20 30 10 1 "opt1" 2 "opt2" 3 "opt3" 4 "Exit" 2> test.txt
----> 如果用户通过按下标号对应的键选择了某个菜单项,该菜单项会高亮显示但不会被选定
----> 直到用户用鼠标或回车键选择了OK按钮时,选项才会最终选定 
----> dialog 命令会将选定的菜单项文本发送到 STDERR 。可以根据需要重定向 STDERR
---> fselect 部件  
----> dialog --title "Select a file" --fselect $HOME/ 10 50 2>file.txt
----> fselect 选项后的第一个参数是窗口中使用的起始目录位置 
----> 可以手动在文本框键入文件名,或者用目录和文件列表来选定
--> dialog 选项
----> 除了标准部件,还可以在 dialog 命令中定制很多不同的选项。你已经看过了 —title 选项的用法 它允许你设置出现在窗口顶部的部件标题
----> --add-widget 继续下个对话框,直到按下Esc或Cancel按钮
----> so many options   can use --help to get infos
--> 在脚本中使用 dialog 命令
----> 如果有Cancel或No按钮,检查 dialog 命令的退出状态码
----> 重定向 STDERR 来获得输出值

3.使用图形
----> KDE和GNOME桌面环境 包含了可以在各自环境下生成X Window图形化部件的命令
----> 本节将描述kdialog和zenity包,它们各自为KDE和GNOME桌面提供了图形化窗口部件
--> KDE 环境   -- KDE图形化环境默认包含kdialog包
---> kdialog部件
---> 使用kdialog
--> GNOME 环境  -- 支持两种流行的可生成标准窗口的包 gdialog & zenity
---> zenity部件
----> --calendar 显示一整月日历
----> --entry 显示文本输入对话窗口
----> --error 显示错误消息对话窗口
----> --file-selection 显示完整的路径名和文件名对话窗口
----> --info 显示信息对话窗口
----> --list 显示多选列表或单选列表对话窗口
----> --notification 显示通知图标
----> --progress 显示进度条对话窗口
----> --question 显示yes/no对话窗口
----> --scale 显示可调整大小的窗口
----> --text-info 显示含有文本的文本框
----> --warning 显示警告对话窗口
---> 在脚本中使用zenity
----> e.g radiolist  zenity --list --radiolist --title "Sys Admin Menu" --column "Select" --column "Menu Item" FALSE "Display diskspace" FALSE "Display users" FALSE "Display memory usage" FALSE "Exit" > $temp2
----> 由于zenity并不支持菜单对话窗口,我们改用单选列表窗口来作为主菜单
----> 该单选列表用了两列,每列都有标题:第一列包含用于选择的单选按钮,第二列是选项文本
----> 当选定一个选项时,该选项的所有文本都会返回到STDOUT


Chapter 19
1.文本处理
--> sed 编辑器  -- stream editor 
----> 流编辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流
----> sed编辑器会执行下列操作  (1) 一次从输入中读取一行数据
----> (2) 根据所提供的编辑器命令匹配数据   (3) 按照命令修改流中的数据
----> (4) 将新的数据输出到 STDOUT
---> use -- sed options script file  
----> -e script 在处理输入时,将 script 中指定的命令添加到已有的命令中
----> -f file 在处理输入时,将 file 中指定的命令添加到已有的命令中
----> -n 不产生命令输出,使用 print 命令来完成输出
----> script 参数指定了应用于流数据上的单个命令
---> 在命令行定义编辑器命令
----> echo "This is a test" | sed 's/test/big test/'  
----> s 命令会用斜线间指定的第二个文本字符串来替换第一个文本字符串模式
----> 's/ori/new/g'  can replace all ori in one line
----> sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT
---> 在命令行使用多个编辑器命令
----> 用 -e 选项 sed -e ' ; ; ' file
---> 从文件中读取编辑器命令
----> 用 -f 选项 sed -f script1.sed data1.txt
----> 避免把sed编辑器脚本文件与bash shell脚本文件搞混,可以使用.sed作为sed文件的扩展名
--> gawk 程序
----> 能提供一个类编程环境来修改和重新组织文件中的数据
----> 可以做  --定义变量来保存数据  --使用算术和字符串操作符来处理数据
----> --使用结构化编程概念(比如 if-then 语句和循环)来为数据处理增加处理逻辑
----> --通过提取数据文件中的数据元素,将其重新排列或格式化,生成格式化报告
---> gawk 命 令 格 式
----> gawk options program file
----> -F fs 指定行中划分数据字段的字段分隔符   -f file 从指定的文件中读取程序
----> -v var=value 定义gawk程序中的一个变量及其默认值
----> -mf N 指定要处理的数据文件中的最大字段数
----> -mr N 指定数据文件中的最大数据行数
----> -W keyword 指定gawk的兼容模式或警告等级
---> 从命令行读取程序脚本
----> gawk '{script}'
----> gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号( {} )中
----> 由于 gawk 命令行假定脚本是单个文本字符串,你还必须将脚本放到单引号中
----> Ctrl+D组合键会在bash中产生一个EOF字符
---> 使用数据字段变量
----> $0 代表整个文本行 $1 代表文本行中的第1个数据字段 $n 代表文本行中的第n个数据字段
----> 每个数据字段都是通过字段分隔符划分的
---> 在程序脚本中使用多个命令
----> 只要在命令之间放个分号即可
---> 从文件中读取程序
----> use  -f filename  -- gawk程序在引用变量值时并未像shell脚本一样使用美元符
---> 在处理数据前运行脚本
----> BEGIN  gawk 'BEGIN{script }'  
----> 它会强制gawk在读取数据前执行 BEGIN 关键字后指定的程序脚本
---> 在处理数据后运行脚本
----> END gawk 'END{script }' 

2.sed 编辑器基础
--> 更多的替换选项 
---> 替换标记
----> 默认情况下它只替换每行中出现的第一处 ||   替换标记会在替换命令字符串之后设置
----> s/ori/new/flag flag= 数字,表明新文本将替换第几处模式匹配的地方
----> g ,表明新文本将会替换所有匹配的文本  p ,表明原先行的内容要打印出来
----> w file ,将替换的结果写到文件 只有那些包含pattern的行才会保存在指定的输出文件中
----> -n 选项将禁止sed编辑器输出 + p 替换标记会输出修改过的行 = 只输出被修改过的行
---> 替换字符
----> use \ 转义
----> sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符
----> sed 's!/bin/bash!/bin/csh!'  感叹号被用作字符串分隔符
--> 使用地址
---> [address]command
----> 如果只想将命令作用于特定行或某些行,则必须用行寻址(line addressing)
----> 两种形式 -- 以数字形式表示行区间  -- 用文本模式来过滤出行
---> 数字方式的行寻址
---->sed编辑器会将文本流中的第一行编号为1,然后继续按顺序为接下来的行分配行号
----> 在命令中指定的地址可以是单个行号,或用起始行号、逗号以及结尾行号指定的一定区间
----> e.g sed '2s/dog/cat/' data1.txt  -- sed '2,3s/dog/cat/' data1.txt
---> 使用文本模式过滤器
----> /pattern/command    必须用正斜线将要指定的 pattern 封起来
----> e.g  sed '/Samantha/s/bash/csh/' /etc/passwd
---> 命令组合  [address]{commands}
--> 删除行  use d  e.g sed 'd' data1.txt
----> 当和指定地址一起使用时,删除命令显然能发挥出最大的功用  e.g sed '2,3d' data1.txt
----> 也可以使用两个文本模式来删除某个区间内的行,但这么做时要小心 sed '/1/ , /3/d' fn
--> 插入和附加文本
----> sed '[address]command\
----> 插入( insert )命令( i )会在指定行前增加一个新行  sed 'i\Test Line 1'
----> 附加( append )命令( a )会在指定行后增加一个新行  sed 'a\Test Line 1'
----> sed '1i\insert line' filename
--> 修改行 c   -- 允许修改数据流中整行文本的内容 
----> e.g   sed '3c\line contents'
----> 你可以在修改命令中使用地址区间,但结果未必如愿 
----> sed编辑器会用这一行文本来替换数据流中的区间文本
--> 转换命令 y  -- 是唯一可以处理单个字符的sed编辑器命令
----> [address]y/inchars/outchars/
----> 转换命令是一个全局命令,也就是说,它会文本行中找到的所有指定字符自动进行转换
--> 回顾打印
----> p 命令用来打印文本行 -- 等号( = )命令用来打印行号 -- l (小写的L)命令用来列出行
---> use p   -- 在命令行上用 -n 选项,你可以禁止输出其他行 只打印包含匹配文本模式的行
---> use =  -- sed '=' data.txt  -- 等号命令会打印行在数据流中的当前行号
---> use l  -- sed -n 'l' data.txt  可以打印数据流中的文本和不可打印的ASCII字符
----> 制表符的位置使用 \t 来显示。行尾的美元符表示换行符 
----> 如果数据流包含了转义字符,列出命令会在必要时候用八进制码来显示
--> 使用 sed 处理文件
---> 写入文件 [address]w filename  e.g   sed '1,2w test.txt' data6.txt
---->sed编辑器会只将包含文本模式的数据行写入目标文件 
---> 从文件读取数据
----> 读取( read )命令( r )允许你将一个独立文件中的数据插入到数据流中
----> [address]r filename --  sed '3r data12.txt' data6.txt
----> sed '/number 2/r data12.txt' data6.txt  
----> 读取命令的另一个很酷的用法是和删除命令配合使用
----> sed '/LIST/{ r data11.txt d }' notice.std

3.  use sed [address num | /pat/] 
----> commands : s/ori/new/g|num|w file    d--delete   i--insert  a-append
----> -n -- quiet   r file -- read file and insert   
----> -e script   -f script_file  


Chapter 20
1.什么是正则表达式
--> 定义  -- 是你所定义的模式模板(pattern template) 可以用它来过滤文本
--> 正则表达式的类型  -- 
----> 正则表达式是通过正则表达式引擎(regular expression engine)实现的 
---> 在Linux中,有两种流行的正则表达式引擎 
----> POSIX基础正则表达式(basic regular expression,BRE)引擎
----> POSIX扩展正则表达式(extended regular expression,ERE)引擎

2.定义 BRE 模式 ^[^][]*$
--> 纯文本
----> 正则表达式并不关心模式在数据流中的位置,出现了多少次 一旦匹配 就会传回
---> 第一条原则:正则表达式模式都区分大小写
----> 可以使用空格和数字 如果你在正则表达式中定义了空格,那么它必须出现在数据流中
--> 特殊字符
---> 正则表达式识别的特殊字符包括: .*[]^${}\+?|() if use need use \ and / need too
--> 锚字符 ^ $
---> 锁定在行首 --  ^ 定义从数据流中文本行的行首开始的模式
----> 要用脱字符,就必须将它放在正则表达式中指定的模式前面
----> 如果你将脱字符放到模式其他位置,那么它就跟普通字符一样,不再是特殊字符了
--> 锁定在行尾 -- $ 定义了行尾锚点
--> 组合锚点 use ^ and $ at same time 
----> 将两个锚点直接组合在一起,之间不加任何文本,这样过滤出数据流中的空白行
--> 点号字符 --  .  
----> 用来匹配除换行符之外的任意单个字符 它必须匹配一个字符 空格也是字符
--> 字符组 [ ]
--> 排除型字符组 [^ ] -- 可以寻找组中没有的字符
--> 区间 
----> 可以用单破折线符号在字符组中表示字符区间
----> e.g [0-9] [a-zA-Z] [a-ch-z] [a-z] [a-f]
--> 特殊的字符组
----> [[:alpha:]] 匹配任意字母字符,不管是大写还是小写
----> [[:alnum:]] 匹配任意字母数字字符0~9、A~Z或a~z
----> [[:blank:]] 匹配空格或制表符  [[:digit:]] 匹配0~9之间的数字
----> [[:lower:]] 匹配小写字母字符a~z  [[:print:]] 匹配任意可打印字符
----> [[:punct:]] 匹配标点符号 
----> [[:space:]] 匹配任意空白字符:空格、制表符、NL、FF、VT和CR
----> [[:upper:]] 匹配任意大写字母字符A~Z
--> 星号 * -- 在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次
----> e.g id* -- match i id idd iddd ...
----> can also use ^[a-z]*$ to match any lower alpha string

3.扩展正则表达式 ^[][^]*?+ {m} {m,n} ()|$
----> POSIX ERE模式包括了一些可供Linux应用和工具使用的额外符号
----> gawk程序能够识别ERE模式,但sed编辑器不能
--> 问号 ? -- 问号表明前面的字符可以出现0次或1次
--> 加号 + -- 加号表明前面的字符可以出现1次或多次,但必须至少出现1次
--> 使用花括号 {} -- 允许你为可重复的正则表达式指定一个上限 {m} {m,n}
----> m :正则表达式准确出现 m 次  | m, n :正则表达式至少出现 m 次,至多 n 次
----> 默认情况下,gawk程序不会识别正则表达式间隔
----> 必须指定gawk程序的 --re-interval命令行选项才能识别正则表达式间隔
----> e.g gawk --re-interval '/be{1}t/{print $0}' 
----> e.g gawk --re-interval '/be{1}t/{print $0}'
--> 管道符号  |  '/cat|dog|duck/'
----> 用逻辑 OR 方式指定正则表达式引擎要用的两个或多个模式
----> 如果任何一个模式匹配了数据流文本,文本就通过测试
----> 如果没有模式匹配,则数据流文本匹配失败
----> 正则表达式和管道符号之间不能有空格
--> 表达式分组 () -- 
----> 正则表达式模式也可以用圆括号进行分组
----> 当你将正则表达式模式分组时,该组会被视为一个标准字符
----> 可以像对普通字符一样给该组使用特殊字符
----> e.g gawk '/(c|b)a(b|t)/{print $0}'  gawk '/Sat(urday)?/{print $0}'

4.正则表达式实战
--> 目录文件计数  用空格来替换冒号
--> 验证电话号码  
--> 解析邮件地址  ^([a-zA-Z0-9_\-\.\+]+) @ ([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$


Chapter 21 
1.多行命令
----> 所有的sed编辑器命令都是针对单行数据执行操作的
----> 三个可用来处理多行文本的特殊命令 N D P
--> next 命令
----> 单行的 next 命令 
----> 小写的 n 命令会告诉sed编辑器移动到数据流中的下一文本行
---> 合并文本行
----> 多行版本的 next 命令(用大写N)会将下一文本行添加到模式空间中已有的文本后
--> 多行删除命令
----> ed编辑器提供了多行删除命令 D ,它只删除模式空间中的第一行。该命令会删除到换行符(含换行符)为止的所有字符
--> 多行打印命令
----> 当多行匹配出现时, P 命令只会打印模式空间中的第一行
----> D 命令的独特之处在于强制sed编辑器返回到脚本的起始处,对同一模式空间中的内容重新执行这些命令 -- 它不会从数据流中读取新的文本行 
----> 在命令脚本中加入 N 命令,你就能单步扫过整个模式空间,将多行一起匹配
----> 接下来,使用 P 命令打印出第一行,然后用 D 命令删除第一行并绕回到脚本的起始处

2.保持空间
----> sed编辑器有另一块称作保持空间(hold space)的缓冲区域。在处理模式空间中的某些行时,可以用保持空间来临时保存一些行
----> 有5条命令可用来操作保持空间   h(p->h)  H(p-ap->h)  g(h->p)  G(h-ap->p) x(ex)

3.排除命令  ! 
----> 感叹号命令( ! )用来排除( negate )命令,也就是让原本会起作用的命令不起作用
----> sed -n '/header/!p' data2.txt
----> 普通 p 命令只打印data2文件中包含单词header的那行。加了感叹号之后,情况就相反了:除了包含单词header那一行外,文件中其他所有的行都被打印出来了

4.改变流
--> 分支
---> [address]b [label]
----> address 参数决定了哪些行的数据会触发分支命令。 label 参数定义了要跳转到的位置
--> 测试
---> [address]t [label]

5.模式替代
--> & 符号 不管模式匹配的是什么样的文本,你都可以在替代模式中使用 & 符号来使用这段文本
---> e.g echo "The cat sleeps in his hat." | sed 's/.at/"&"/g'
--> 替代单独的单词
----> sed编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。sed编辑器会给第一个子模式分配字符 \1 ,给第二个子模式分配字符 \2 ,依此类推
----> echo "The System Administrator manual" | sed '
----> s/\(System\) Administrator/\1 User/'
----> The System User manual

6.在脚本中使用 sed
--> 使用包装脚本
--> 重定向 sed 的输出

7.创建 sed 实用工具
--> 加倍行间距  sed 'G' data2.txt
---> sed '$!G' data2.txt
----> 可以用排除符号(!)和尾行符号($)来确保脚本不会将空白行加到数据流的最后一行后面
--> 对可能含有空白行的文件加倍行间距
---> sed '/^$/d ; $!G' data6.txt
--> 给文件中的行编号
---> sed '=' data2.txt
----> sed '=' data2.txt | sed 'N; s/\n/ /'
--> 打印末尾行  sed -n '$p' data2.txt
--> 删除行
--> 删除 HTML 标签  sed 's/<[^>]*>//g' data11.txt

//The bleow is casully write

Chapter 22
1.使用变量
--> 内建变量
--> 自定义变量
2.处理数组
--> 定义数组变量
--> 遍历数组变量
--> 删除数组变量
3.使用模式
--> 正则表达式
--> 匹配操作符
--> 数学表达式 
4.结构化命令
--> if 语句
--> while 语句
--> do-while 语句
--> for 语句
5.格式化打印
6.内建函数
--> 数学函数
--> 字符串函数
--> 时间函数
7.自定义函数
--> 定义函数 function name([variables]) { statements }
--> 使用自定义函数
--> 创建函数库
8.实例


Chapter 23
1.什么是 dash shell
2.dash shell 的特性
3.dash 脚本编程  #!/bin/dash
4.zsh shell
5.zsh shell 的组成
6.zsh 脚本编程


Chapter 24
1.归档
---> tar -cf archive.tar /home/Christine/Project/*.* 2>/dev/null
---> ls -l archive.tar.gz

--skip--




Chapter 25
1.MySQL 数据库
--> 安装mysql
---> 依次输入这三条命令
---> sudo apt-get install mysql-server
---> sudo apt install mysql-client
---> sudo apt install libmysqlclient-dev
--> 检验是否安装mysql成功
---> sudo netstat -tap | grep mysql
--> 实现远程控制mysql
---> sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
---> 注释掉bind-address = 127.0.0.1   exit 
---> GRANT ALL PRIVILEGES ON . TO 'root'@'%' IDENTIFIED BY '你的密码' WITH GRANT OPTION;
---> flush privileges;
---> exit
---> service mysql restart ;







































































































































































































































